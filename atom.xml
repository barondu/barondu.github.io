<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Baron的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://barondu.com/"/>
  <updated>2017-01-09T18:43:47.000Z</updated>
  <id>http://barondu.com/</id>
  
  <author>
    <name>Baron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记 OSC_Concurrency2</title>
    <link href="http://barondu.com/2017/01/09/Concurrency2/"/>
    <id>http://barondu.com/2017/01/09/Concurrency2/</id>
    <published>2017-01-09T17:33:27.000Z</published>
    <updated>2017-01-09T18:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Concurrency-2"><a href="#Concurrency-2" class="headerlink" title="Concurrency 2"></a>Concurrency 2</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li><strong>Software approaches</strong>: Peterson’s solution Hardware approaches:</li>
<li><strong>Disabling interrupts</strong>:<ul>
<li><code>test_and_set()</code></li>
<li><code>compare_and_swap()</code></li>
</ul>
</li>
<li>Higher level approaches include <strong>mutexes</strong> and <strong>semaphores</strong><h3 id="Peterson’s-Solution"><a href="#Peterson’s-Solution" class="headerlink" title="Peterson’s Solution"></a>Peterson’s Solution</h3></li>
<li>Peterson’s solution is a <strong>software based solution</strong> which worked well for <strong>older machines</strong></li>
<li>Two <strong>shared variables</strong> are used:<ul>
<li>turn: indicates <strong>which process is next</strong> to enter its critical section </li>
<li>boolean flag[2]: indicates that a <strong>process is ready</strong> to enter its critical section</li>
</ul>
</li>
<li>It is restricted[限制] to <strong>two processes</strong> that execute in <strong>strict alternation</strong>[严格的交替]<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	<span class="built_in">flag</span>[j] = <span class="literal">true</span>; <span class="comment">// j wants to enter critical section turn = i; // allow i to access first</span></div><div class="line">	<span class="keyword">while</span> (<span class="built_in">flag</span>[i] &amp;&amp; turn == i);</div><div class="line">	<span class="comment">// whilst i wants to access critical section</span></div><div class="line">	<span class="comment">// and its i’s turn, apply busy waiting </span></div><div class="line">	</div><div class="line">	<span class="comment">// CRITICAL SECTION</span></div><div class="line">	</div><div class="line">	<span class="built_in">flag</span>[j] = <span class="literal">false</span>;</div><div class="line">	<span class="comment">// remainder section</span></div><div class="line">&#125; <span class="keyword">while</span> (...);</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>Peterson’s solution satisfies all requirements for mutual exclusion</li>
<li><strong>Mutual exclusion requirement</strong>: the variable turn can have <strong>at most one value at a time</strong><ul>
<li>while(flag[i] &amp;&amp; turn == i)or while(flag[j] &amp;&amp; turn == j) is true and at most <strong>one process can enter its critical section</strong> (mutual exclusion)</li>
</ul>
</li>
</ul>
<h3 id="Disabling-Interrupts"><a href="#Disabling-Interrupts" class="headerlink" title="Disabling Interrupts"></a>Disabling Interrupts</h3><ul>
<li><p><strong>Disable interrupts</strong> whilst <strong>executing a critical section</strong> and prevent interruption (i.e., interrupts from timers, I/O devices, etc.)</p>
<ul>
<li>Think of the counter++ example <figure class="highlight plain"><figcaption><span>= counter;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">register = register + 1</div><div class="line">counter = register;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Disabling interrupts “may” be appropriate on <strong>a single CPU machine</strong> </p>
</li>
<li>This is <strong>inefficient on modern multi-core/multi processor machines</strong><ul>
<li>Disabling interrupts on all cores/CPUs <strong>takes time</strong> and <strong>causes delays</strong> </li>
<li><strong>CPU capacity[能力] is lost</strong> on other cores</li>
</ul>
</li>
</ul>
<h3 id="Atomic-Instructions"><a href="#Atomic-Instructions" class="headerlink" title="Atomic Instructions"></a>Atomic Instructions</h3><ul>
<li>Implement <code>test_and_set()</code> and <code>swap_and_compare()</code> instructions as a <strong>set of atomic (UN-interruptible) instructions</strong><ul>
<li>Reading and setting the variable(s) is done as one “complete” set of instructions</li>
<li>If <code>test_and_set()</code> or <code>compare_and_swap()</code> are called simultaneously, they will be <strong>executed sequentially</strong></li>
</ul>
</li>
<li>They are used in in combination with <strong>global lock variables</strong>, assumed to be true if the lock is <strong>in use</strong></li>
</ul>
<h4 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test_and_set()"></a>test_and_set()</h4><blockquote>
<p>Test and set must be <strong>atomic/UN-interruptable</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Test and set method</span></div><div class="line"><span class="function">boolean <span class="title">test_and_set</span>(<span class="params">boolean * <span class="keyword">lock</span></span>) </span>&#123; </div><div class="line">	boolean rv = *<span class="keyword">lock</span>;</div><div class="line">	*<span class="keyword">lock</span> = <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> rv;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Example of using test and set method</span></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	<span class="comment">// WHILE the lock is in use, apply busy waiting</span></div><div class="line">	<span class="keyword">while</span> (test_and_set(&amp;<span class="keyword">lock</span>)); </div><div class="line">	<span class="comment">// Lock was false, now true</span></div><div class="line">	<span class="comment">// CRITICAL SECTION</span></div><div class="line">	...</div><div class="line">	<span class="keyword">lock</span> = <span class="literal">false</span>;</div><div class="line">	...</div><div class="line">	<span class="comment">// remainder section</span></div><div class="line">&#125; <span class="keyword">while</span> (...)</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="compare-and-swap"><a href="#compare-and-swap" class="headerlink" title="compare_and_swap()"></a>compare_and_swap()</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Compare and swap method</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span>(<span class="params"><span class="keyword">int</span> *<span class="keyword">lock</span>, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value</span>) </span>&#123; </div><div class="line">	<span class="keyword">int</span> temp = *<span class="keyword">lock</span>;</div><div class="line">	<span class="keyword">if</span>(*<span class="keyword">lock</span> == expected)</div><div class="line">	*<span class="keyword">lock</span> = new_value; <span class="keyword">return</span> temp;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Example using compare and swap method</span></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	<span class="comment">// While the lock is in use (i.e. == 1), apply busy waiting</span></div><div class="line">	<span class="keyword">while</span> (compare_and_swap(&amp;<span class="keyword">lock</span>, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); </div><div class="line">	<span class="comment">// Lock was false, now true</span></div><div class="line">	<span class="comment">// CRITICAL SECTION</span></div><div class="line">	...</div><div class="line">	<span class="keyword">lock</span> = <span class="number">0</span>;</div><div class="line">	...</div><div class="line">	<span class="comment">// remainder section</span></div><div class="line">&#125; <span class="keyword">while</span> (...);</div></pre></td></tr></table></figure>
<p>Disadvantages:</p>
<ul>
<li><code>test_and_set()</code>and <code>compare_and_swap()</code> are <strong>hardware instructions</strong> and (usually) <strong>not directly accessible</strong> to the user</li>
<li><strong>Busy waiting</strong> is used </li>
<li><strong>Starvation</strong> is possible </li>
<li><strong>Deadlock</strong> is possible</li>
</ul>
<p>The <strong>OS uses the hardware instructions</strong> to implement <strong>higher level mechanisms/instructions</strong> for mutual exclusion, i.e. <strong>mutexes</strong> and <strong>semaphores</strong></p>
<p>##Summary</p>
<ul>
<li>Peterson’s solution (software)</li>
<li>Hardware instructions: interrupt disabling, (test_and_set, compare_and_swap)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Concurrency-2&quot;&gt;&lt;a href=&quot;#Concurrency-2&quot; class=&quot;headerlink&quot; title=&quot;Concurrency 2&quot;&gt;&lt;/a&gt;Concurrency 2&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Software approaches&lt;/strong&gt;: Peterson’s solution Hardware approaches:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disabling interrupts&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test_and_set()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compare_and_swap()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Higher level approaches include &lt;strong&gt;mutexes&lt;/strong&gt; and &lt;strong&gt;semaphores&lt;/strong&gt;&lt;h3 id=&quot;Peterson’s-Solution&quot;&gt;&lt;a href=&quot;#Peterson’s-Solution&quot; class=&quot;headerlink&quot; title=&quot;Peterson’s Solution&quot;&gt;&lt;/a&gt;Peterson’s Solution&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;Peterson’s solution is a &lt;strong&gt;software based solution&lt;/strong&gt; which worked well for &lt;strong&gt;older machines&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;shared variables&lt;/strong&gt; are used:&lt;ul&gt;
&lt;li&gt;turn: indicates &lt;strong&gt;which process is next&lt;/strong&gt; to enter its critical section &lt;/li&gt;
&lt;li&gt;boolean flag[2]: indicates that a &lt;strong&gt;process is ready&lt;/strong&gt; to enter its critical section&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It is restricted[限制] to &lt;strong&gt;two processes&lt;/strong&gt; that execute in &lt;strong&gt;strict alternation&lt;/strong&gt;[严格的交替]&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt;[j] = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// j wants to enter critical section turn = i; // allow i to access first&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt;[i] &amp;amp;&amp;amp; turn == i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// whilst i wants to access critical section&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// and its i’s turn, apply busy waiting &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// CRITICAL SECTION&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;flag&lt;/span&gt;[j] = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// remainder section&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (...);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="concurrency" scheme="http://barondu.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Concurrency1</title>
    <link href="http://barondu.com/2017/01/09/Concurrency1/"/>
    <id>http://barondu.com/2017/01/09/Concurrency1/</id>
    <published>2017-01-09T14:09:27.000Z</published>
    <updated>2017-01-09T14:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Concurrency-1"><a href="#Concurrency-1" class="headerlink" title="Concurrency 1"></a>Concurrency 1</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>Examples of <strong>concurrency issues</strong> (e.g. counter++)</li>
<li>Root causes of <strong>concurrency issues</strong></li>
<li><strong>Critical sections</strong> and <strong>mutual exclusion</strong> </li>
<li><strong>Requirements and approaches</strong> for mutual exclusion</li>
<li>###concurrency</li>
<li>Threads and processes execute concurrently or in parallel and can share resources<ul>
<li>Multiprogramming/multiprocessing <strong>improves system utilisation</strong></li>
</ul>
</li>
<li>A process/thread can be <strong>interrupted at any point in time</strong> (I/O, timer)<ul>
<li>The process “state” is <strong>saved</strong> in the p<strong>rocess control block</strong> </li>
</ul>
</li>
<li>The outcome of programs may become <strong>unpredictable</strong>[不可预知的]<ul>
<li>Sharing data can lead to <strong>inconsistencies</strong>[矛盾]</li>
<li>I.e., the <strong>outcome of execution</strong> may <strong>depend on the order</strong> win which instructions are carried out</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="Incrementing-a-counter"><a href="#Incrementing-a-counter" class="headerlink" title="Incrementing a counter"></a>Incrementing a counter</h4><ul>
<li><code>counter++</code> consists of three separate actions:<ul>
<li>1 read the value of counter and <strong>store it in a register</strong></li>
<li>2 add one to the value in the register</li>
<li>3 store the value of the register <strong>in counter</strong></li>
</ul>
</li>
<li>The above actions are <strong>NOT</strong> “atomic”, e.g. they can be interrupted by the timer (⇒ <strong>context switch</strong>)</li>
</ul>
<h4 id="Bounded-Buffers"><a href="#Bounded-Buffers" class="headerlink" title="Bounded Buffers"></a>Bounded Buffers</h4><ul>
<li>Consider a <strong>bounded buffer</strong> in which N items can be stored</li>
<li>A <strong>counter</strong> is maintained to count the number of items currently in the buffer<ul>
<li><strong>Incremented</strong> when an item is <strong>added</strong> </li>
<li><strong>Decremented</strong> when an item is <strong>removed</strong></li>
</ul>
</li>
<li>Similar <strong>concurrency problems</strong> as with the calculation of sums happen in the bounded buffer (producer/consumer) problem</li>
</ul>
<h4 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h4><ul>
<li>A <strong>race condition occurs</strong> when multiple threads/processes <strong>access shared data</strong> and the result is dependent on <strong>the order in which the instructions are interleaved</strong></li>
</ul>
<h3 id="Concurrency-within-the-OS"><a href="#Concurrency-within-the-OS" class="headerlink" title="Concurrency within the OS"></a>Concurrency within the OS</h3><p>Data Structures</p>
<ul>
<li><strong>Kernels are preemptive</strong> these days (⇔ non-preemptive) <ul>
<li><strong>Multiple processes are running</strong> in the kernel</li>
<li>I.e. kernel <strong>processes can be interrupted</strong> at any point</li>
</ul>
</li>
<li>The kernel maintains <strong>data structures</strong>, e.g. process tables, memory structures, open file lists, etc.</li>
<li>These data structures are accessed <strong>concurrently/in parallel</strong> </li>
<li>These can be subject to <strong>concurrency issues</strong></li>
</ul>
<p>Resources</p>
<ul>
<li>Processes share resources, including memory, files, processor time, printers, I/O devices, etc.</li>
<li>The operating system must:<ul>
<li><strong>Allocate and deallocate</strong> these resources safely (i.e. avoid interference, deadlocks and starvation)</li>
<li>Make sure that interactions within the OS d<strong>o not result in race conditions</strong></li>
<li>The operating system must provide locking mechanisms to implement/support mutual exclusion (and prevent starvation and deadlocks)</li>
</ul>
</li>
</ul>
<h3 id="Critical-Sections-临界段-Mutual-Exclusion-互斥"><a href="#Critical-Sections-临界段-Mutual-Exclusion-互斥" class="headerlink" title="Critical Sections[临界段], Mutual Exclusion[互斥]"></a>Critical Sections[临界段], Mutual Exclusion[互斥]</h3><ul>
<li>A critical section is a set of instructions in which <strong>shared variables are changed</strong></li>
<li><p><strong>Mutual exclusion</strong> must be enforced <strong>for critical sections</strong></p>
<ul>
<li>Only <strong>one process at a time</strong> should be in the critical section (mutual exclusion)</li>
<li>Processes have to <strong>get “permission”</strong> before entering their critical section<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">	<span class="params">...</span></div><div class="line">	<span class="comment">// ENTRY to critical section</span></div><div class="line">	critical section, e.g.counter++;</div><div class="line">	<span class="comment">// EXIT critical section</span></div><div class="line">	remaining code</div><div class="line">	<span class="params">...</span></div><div class="line">&#125; <span class="keyword">while</span> (<span class="params">...</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Any solution to the critical section problem</strong> must satisfy the following <strong>requirements</strong>:</p>
<ul>
<li><strong>Mutual exclusion</strong>: only one process can be in its critical section at any one point in time</li>
<li><strong>Progress</strong>: any process must be able to enter its critical section at some point in time</li>
<li><strong>Fairness/bounded waiting</strong>: processes cannot be made to wait indefinitely</li>
</ul>
</li>
<li>These requirements have to be satisfied, <strong>independent of the order</strong> in which sequences are executed</li>
</ul>
<h4 id="Enforcing-Mutual-Exclusion"><a href="#Enforcing-Mutual-Exclusion" class="headerlink" title="Enforcing Mutual Exclusion"></a>Enforcing Mutual Exclusion</h4><ul>
<li><strong>Approaches</strong> for mutual exclusion can be:<ul>
<li><strong>Software based:</strong> Peterson’s solution</li>
<li><strong>Hardware based</strong>: <code>test_and_set(), swap_and_compare()</code></li>
<li><strong>Based on</strong>:<ul>
<li>Mutexes</li>
<li>Semaphores</li>
<li>Monitors (software construct within the programming languages)</li>
</ul>
</li>
</ul>
</li>
<li>In addition to mutual exclusion, <strong>deadlocks</strong> have to be prevented (next week’s subject)</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Examples of <strong>concurrency issues</strong> (e.g. counter++)</li>
<li>Root causes of <strong>concurrency issues</strong></li>
<li><strong>Critical sections</strong> and <strong>mutual exclusion</strong> </li>
<li><strong>Requirements and approaches</strong> for mutual exclusion</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Concurrency-1&quot;&gt;&lt;a href=&quot;#Concurrency-1&quot; class=&quot;headerlink&quot; title=&quot;Concurrency 1&quot;&gt;&lt;/a&gt;Concurrency 1&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Examples of &lt;strong&gt;concurrency issues&lt;/strong&gt; (e.g. counter++)&lt;/li&gt;
&lt;li&gt;Root causes of &lt;strong&gt;concurrency issues&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Critical sections&lt;/strong&gt; and &lt;strong&gt;mutual exclusion&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Requirements and approaches&lt;/strong&gt; for mutual exclusion&lt;/li&gt;
&lt;li&gt;###concurrency&lt;/li&gt;
&lt;li&gt;Threads and processes execute concurrently or in parallel and can share resources&lt;ul&gt;
&lt;li&gt;Multiprogramming/multiprocessing &lt;strong&gt;improves system utilisation&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A process/thread can be &lt;strong&gt;interrupted at any point in time&lt;/strong&gt; (I/O, timer)&lt;ul&gt;
&lt;li&gt;The process “state” is &lt;strong&gt;saved&lt;/strong&gt; in the p&lt;strong&gt;rocess control block&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The outcome of programs may become &lt;strong&gt;unpredictable&lt;/strong&gt;[不可预知的]&lt;ul&gt;
&lt;li&gt;Sharing data can lead to &lt;strong&gt;inconsistencies&lt;/strong&gt;[矛盾]&lt;/li&gt;
&lt;li&gt;I.e., the &lt;strong&gt;outcome of execution&lt;/strong&gt; may &lt;strong&gt;depend on the order&lt;/strong&gt; win which instructions are carried out&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="concurrency" scheme="http://barondu.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Processes4</title>
    <link href="http://barondu.com/2017/01/09/Processes4/"/>
    <id>http://barondu.com/2017/01/09/Processes4/</id>
    <published>2017-01-09T14:05:27.000Z</published>
    <updated>2017-01-09T14:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Processes-4"><a href="#Processes-4" class="headerlink" title="Processes 4"></a>Processes 4</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>Multi-level feedback queues</li>
<li>Scheduling in Window 7 + illustration Scheduling in </li>
<li>Linux (implementation in labs) Scheduling related processes/threads</li>
</ul>
<h3 id="Multi-level-Feedback-Queues"><a href="#Multi-level-Feedback-Queues" class="headerlink" title="Multi-level Feedback Queues"></a>Multi-level Feedback Queues</h3><ul>
<li>Different <strong>scheduling algorithms</strong> can be used for the <strong>individual queues</strong> (e.g., round robin, SJF, FCFS)</li>
<li><p><strong>Feedback queues</strong> allow <strong>priorities to change dynamically</strong>[动态的], i.e., jobs can move between queues:</p>
<ul>
<li>Move to <strong>lower priority queue</strong> if too much CPU time is used (prioritise I/O and interactive processes)</li>
<li>Move to <strong>higher priority queue</strong> to prevent <strong>starvation</strong> and avoid <strong>inversion[反转] of control</strong></li>
</ul>
</li>
<li><p>Defining characteristics of feedback queues include: </p>
<ul>
<li>The <strong>number of queues</strong></li>
<li>The <strong>scheduling algorithms</strong> used for the individual queues </li>
<li><strong>Migration policy</strong>[迁移政策] between queues</li>
<li>Initial <strong>access</strong> to the queues<br>Feedback queues are highly <strong>configurable</strong>[可配置] and offer significant <strong>flexibility</strong>[灵活性，适应性]</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h4><ul>
<li>An <strong>interactive system</strong>[交互系统] using a <strong>preemptive scheduler</strong> with <strong>dynamic priority levels</strong><ul>
<li>Two priority classes with 16 different priority levels exist<ul>
<li>“<strong>Real time</strong>” processes/threads have a <strong>fixed priority level</strong></li>
<li>“<strong>Variable</strong>” processes/threads can have their priorities <strong>boosted temporarily</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>A <strong>round robin algorithm</strong> is used within the queues</p>
</li>
<li><p>Priorities are based on the <strong>process base priority</strong> (between 0-15) and <strong>thread base priority</strong> (±2 relative to the process priority)</p>
</li>
<li>A thread’s priority dynamically changes during execution between its base priority and the maximum priority within its class<ul>
<li><strong>Interactive I/O bound processes</strong> (e.g. keyboard) receive a <strong>larger boost</strong> </li>
<li>Boosting priorities prevents <strong>priority inversion</strong></li>
</ul>
</li>
</ul>
<h3 id="Scheduling-in-Linux"><a href="#Scheduling-in-Linux" class="headerlink" title="Scheduling in Linux"></a>Scheduling in Linux</h3><h4 id="The-Completely-Fair-Scheduler"><a href="#The-Completely-Fair-Scheduler" class="headerlink" title="The Completely Fair Scheduler"></a>The Completely Fair Scheduler</h4><ul>
<li>Linux distinguishes[区分] between two types of tasks for scheduling:<ul>
<li><strong>Real time tasks</strong> (to be POSIX compliant), divided into: <ul>
<li>Real time FIFO tasks</li>
<li>Real time Round Robin tasks</li>
</ul>
</li>
<li><strong>Time sharing tasks</strong> using a <strong>preemptive</strong> approach (similar to <strong>variable</strong> in Windows)</li>
</ul>
</li>
<li>The most recent scheduling algorithm in Linux for <strong>time sharing tasks</strong> is the “<strong>completely fair scheduler</strong>” </li>
</ul>
<p>Real-Time Tasks</p>
<ul>
<li><strong>Real time FIFO</strong> tasks have the <strong>highest priority</strong> and are scheduled using a <strong>FCFS approach</strong>, using <strong>preemption if a higher priority</strong> job shows up</li>
<li><strong>Real time round robin tasks</strong> are preemptable by <strong>clock interrupts</strong> and have a time slice associated with them</li>
<li>Both approaches <strong>cannot guarantee hard deadlines</strong></li>
</ul>
<p>Time Sharing Tasks</p>
<ul>
<li>The CFS <strong>divides the CPU time</strong> between all processes </li>
<li>If all N processes have the <strong>same priority</strong>:<ul>
<li>They will be allocated a “time slice” equal to 1/N times the available CPU time<ul>
<li>I.e., if N equals 5, every process will receive 20% of the processor’s time</li>
</ul>
</li>
</ul>
</li>
<li>The length of the <strong>time slice</strong> and the “available CPU time” are based on the <strong>targeted latency[延迟]</strong> (⇒ every process should <strong>run at least once</strong> during this interval)</li>
<li>If N is <strong>very large</strong>, the <strong>context switch time will be dominant</strong>, hence a lower bound on the “time slice” is imposed by the minimum granularity[粒度]<ul>
<li>A process’s time slice can be no <strong>less than</strong> the <strong>minimum granularity</strong> (response time will deteriorate[恶化])</li>
</ul>
</li>
<li>A <strong>weighting scheme</strong> is used to take different priorities into account If process have <strong>different priorities:</strong><ul>
<li>Every process <em>i</em> is allocated a <strong>weight</strong> <em>Wi</em> that reflects its priority</li>
</ul>
</li>
<li>The tasks with the <strong>lowest amount</strong> of “<strong>used CPU time</strong>” are <strong>selected first</strong></li>
</ul>
<p>Shared Queues  </p>
<ul>
<li>A single or multi-level queue <strong>shared</strong> between all CPUs </li>
<li>Advantage: automatic <strong>load balancing</strong><br>Disadvantages:<ul>
<li><strong>Contention</strong>[竞争] for the queues (locking is needed)</li>
<li>“All CPUs are equal, but some are more equal than others” : does not account for <strong>processor affinity</strong>[紧密度]:<ul>
<li><strong>Cache</strong> becomes invalid when moving to a different CPU</li>
<li>Translation look aside buffers (TLBs - part of the MMU) become invalid</li>
</ul>
</li>
</ul>
</li>
<li>Windows will allocate the <strong>highest priority threads</strong> to the individual CPUs/cores</li>
</ul>
<p>Private Queues</p>
<ul>
<li>Each process/thread is assigned to a queue <strong>private</strong> to an individual CPU </li>
<li>Advantages:<ul>
<li><strong>CPU affinity</strong> is automatically satisfied </li>
<li><strong>Contention</strong> for shared queue is minimised</li>
</ul>
</li>
<li>Disadvantages: less <strong>load balancing</strong></li>
<li><strong>Push</strong> and <strong>pull migration</strong> between CPUs is possible</li>
</ul>
<h3 id="Related-vs-Unrelated-Threads"><a href="#Related-vs-Unrelated-Threads" class="headerlink" title="Related vs. Unrelated Threads"></a>Related vs. Unrelated Threads</h3><p><strong>Related: multiple threads</strong> that <strong>communicate</strong> with one another and <strong>ideally run</strong> together (e.g. search algorithm)</p>
<p><strong>Unrelated</strong>: e.g. processes threads that are <strong>independent</strong>, possibly started by <strong>different users</strong> running <strong>different programs</strong></p>
<p>####Related Threads</p>
<ul>
<li>The aim is to get threads <strong>running</strong>, as much as possible, at the <strong>same</strong> time across <strong>multiple CPUs</strong></li>
<li>Approaches include:<ul>
<li><strong>Space</strong> sharing</li>
<li><strong>Gang</strong> scheduling</li>
</ul>
</li>
</ul>
<p>####Gang scheduling</p>
<ul>
<li>Time slices are <strong>synchronised</strong>[同步的] and the scheduler <strong>groups threads</strong> together to run simultaneously (as much as possible)</li>
<li>A <strong>preemptive</strong> algorithm</li>
<li><strong>Blocking threads</strong> result in idle CPUs</li>
</ul>
<p>##Summary</p>
<ul>
<li>Scheduling on Windows and Linux</li>
<li>Multi-processor/core scheduling is “a bit different” (load balancing, processor affinity, etc.)<ul>
<li>Related and unrelated threads </li>
<li>Shared or private queues</li>
<li>Space scheduling or gang scheduling</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Processes-4&quot;&gt;&lt;a href=&quot;#Processes-4&quot; class=&quot;headerlink&quot; title=&quot;Processes 4&quot;&gt;&lt;/a&gt;Processes 4&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Multi-level feedback queues&lt;/li&gt;
&lt;li&gt;Scheduling in Window 7 + illustration Scheduling in &lt;/li&gt;
&lt;li&gt;Linux (implementation in labs) Scheduling related processes/threads&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Multi-level-Feedback-Queues&quot;&gt;&lt;a href=&quot;#Multi-level-Feedback-Queues&quot; class=&quot;headerlink&quot; title=&quot;Multi-level Feedback Queues&quot;&gt;&lt;/a&gt;Multi-level Feedback Queues&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Different &lt;strong&gt;scheduling algorithms&lt;/strong&gt; can be used for the &lt;strong&gt;individual queues&lt;/strong&gt; (e.g., round robin, SJF, FCFS)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Feedback queues&lt;/strong&gt; allow &lt;strong&gt;priorities to change dynamically&lt;/strong&gt;[动态的], i.e., jobs can move between queues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Move to &lt;strong&gt;lower priority queue&lt;/strong&gt; if too much CPU time is used (prioritise I/O and interactive processes)&lt;/li&gt;
&lt;li&gt;Move to &lt;strong&gt;higher priority queue&lt;/strong&gt; to prevent &lt;strong&gt;starvation&lt;/strong&gt; and avoid &lt;strong&gt;inversion[反转] of control&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Defining characteristics of feedback queues include: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;number of queues&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;scheduling algorithms&lt;/strong&gt; used for the individual queues &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Migration policy&lt;/strong&gt;[迁移政策] between queues&lt;/li&gt;
&lt;li&gt;Initial &lt;strong&gt;access&lt;/strong&gt; to the queues&lt;br&gt;Feedback queues are highly &lt;strong&gt;configurable&lt;/strong&gt;[可配置] and offer significant &lt;strong&gt;flexibility&lt;/strong&gt;[灵活性，适应性]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="processes" scheme="http://barondu.com/tags/processes/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Processes3</title>
    <link href="http://barondu.com/2017/01/08/Processes3/"/>
    <id>http://barondu.com/2017/01/08/Processes3/</id>
    <published>2017-01-08T23:27:27.000Z</published>
    <updated>2017-01-08T23:30:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Processes-3"><a href="#Processes-3" class="headerlink" title="Processes 3"></a>Processes 3</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>1 Threads vs. processes<br>2 Different thread implementations<br>3 POSIX Threads (PThreads)</p>
<h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><h4 id="Threads-from-an-OS-Perspective-观点"><a href="#Threads-from-an-OS-Perspective-观点" class="headerlink" title="Threads from an OS Perspective[观点]"></a>Threads from an OS Perspective[观点]</h4><ul>
<li>A process consists of two <strong>fundamental units</strong><ul>
<li><strong>Resources:</strong> all related resources are grouped together<ul>
<li>A logical address space containing the process image (program, data, heap, stack)</li>
<li>Files, I/O devices, I/O channels, . . .</li>
</ul>
</li>
<li><strong>Execution trace</strong>[执行追踪], i.e., an entity that gets executed</li>
</ul>
</li>
<li>A process can <strong>share its resources</strong> between <strong>multiple execution traces</strong>, i.e., multiple threads running in the same resource environment<br><img src="http://ww3.sinaimg.cn/mw690/005P51vHgw1fbif3ey9okj317q0oc0yg.jpg" alt=""></li>
</ul>
<a id="more"></a>
<ul>
<li>Every thread has its own <strong>execution context</strong> (e.g. program counter, stack, registers)</li>
<li>All threads have <strong>access</strong> to the process’ <strong>shared resources</strong><ul>
<li>E.g. files, one thread opens a file, all threads of the same process can access the file</li>
<li>Global variables, memory, etc. (⇒ synchronisation!)</li>
</ul>
</li>
<li>Some CPUs (hyperthreaded ones) have direct <strong>hardware support</strong> for <strong>multi-threading</strong></li>
<li>Similar to processes, threads have:<ul>
<li><strong>States</strong> and <strong>transitions</strong> (new, running, blocked, ready, terminated) </li>
<li>A <strong>thread control block</strong><br>Threads create/terminate/switch with <strong>less overhead</strong>  (address space remains the same for threads of the same process)</li>
</ul>
</li>
<li><strong>Inter-thread</strong> communication is easier/faster than <strong>inter-process</strong> communication (threads share memory by default)</li>
<li><strong>No protection boundaries</strong>[边界] are required in the address space (threads are cooperating, belong to the same user, and have a common goal)</li>
<li><strong>Synchronisation</strong> has to be considered carefully!</li>
</ul>
<h4 id="Why-Use-Threads"><a href="#Why-Use-Threads" class="headerlink" title="Why Use Threads"></a>Why Use Threads</h4><ul>
<li><strong>Multiple related activities</strong> apply to the <strong>same resources</strong>, these resources should be accessible/<strong>shared</strong></li>
<li>Processes will often contain <strong>multiple blocking tasks</strong><ul>
<li>I/O operations (thread blocks, interrupt marks completion)</li>
<li>Memory access: pages faults are result in blocking</li>
</ul>
</li>
<li>Such activities should be carried out in <strong>parallel/concurrently</strong></li>
<li><strong>Application examples</strong>: webservers, make program, spreadsheets, word processors, processing large data volumes</li>
</ul>
<p>####OS Implementations of Threads</p>
<ul>
<li><strong>User</strong> threads</li>
<li><strong>Kernel</strong> threads</li>
<li><strong>Hybrid</strong>[混合] implementations</li>
</ul>
<h3 id="User-Threads"><a href="#User-Threads" class="headerlink" title="User Threads"></a>User Threads</h3><p>Many-to-One<br><img src="http://ww1.sinaimg.cn/mw690/005P51vHgw1fbinuru9h3j31as0zeakj.jpg" alt=""></p>
<ul>
<li><strong>Thread management</strong> (creating, destroying, scheduling, thread control block manipulation[处理]) is carried out <strong>in user space</strong> with the help of a user library</li>
<li>The process maintains a <strong>thread table</strong> managed by the <strong>runtime system</strong> without the <strong>kernel’s knowledge</strong><ul>
<li>Similar to <strong>process table</strong></li>
<li>Used for <strong>thread switching</strong> </li>
<li>Tracks thread related information</li>
</ul>
</li>
</ul>
<p>Advantages:</p>
<ul>
<li>Threads are in user space (i.e., <strong>no mode switches</strong> required)</li>
<li><strong>Full control</strong> over the thread scheduler</li>
<li><strong>OS independent</strong>[独立不受约束] (threads can run on OS that do not support them)</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><strong>Blocking system calls</strong> suspend[延缓] the entire process (user threads are mapped onto a single process, managed by the kernel)</li>
<li><strong>No true parallelism</strong> (a process is scheduled on a single CPU)</li>
<li><strong>Clock interrupts</strong> are non-existent (i.e. user threads are non-preemptive) </li>
<li><strong>Page faults</strong>[错误] result in blocking the process</li>
</ul>
<h3 id="Kernel-Threads"><a href="#Kernel-Threads" class="headerlink" title="Kernel Threads"></a>Kernel Threads</h3><p>One-to-One<br><img src="http://ww4.sinaimg.cn/mw690/005P51vHgw1fbinuxcc41j317i0r4n2k.jpg" alt=""></p>
<ul>
<li>The <strong>kernel manages</strong> the threads, user application accesses threading facilities[工具] through <strong>API</strong> and <strong>system calls</strong><ul>
<li><strong>Thread table</strong> is in the kernel, containing thread control blocks (subset of process control blocks)</li>
<li>If a <strong>thread blocks</strong>, the kernel chooses thread from same or different process (↔ user threads)</li>
</ul>
</li>
<li>Windows and Linux apply this approach</li>
</ul>
<p>Advantages:</p>
<ul>
<li>True parallelism can be achieved </li>
<li>No run-time system needed</li>
</ul>
<p>Disadvantage:</p>
<ul>
<li>Frequent <strong>mode switches</strong> take place, resulting in lower performance <ul>
<li>Frequent <strong>mode switches</strong> take place, resulting in <strong>lower performance</strong></li>
</ul>
</li>
</ul>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p><img src="http://ww3.sinaimg.cn/mw690/005P51vHgw1fbiotlbg2qj31oi0nyk1b.jpg" alt=""></p>
<h3 id="Hybrid-Implementations"><a href="#Hybrid-Implementations" class="headerlink" title="Hybrid Implementations"></a>Hybrid Implementations</h3><p>Many-to-Many<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbinuv2e7qj31380wytfi.jpg" alt=""></p>
<ul>
<li>User threads are <strong>multiplexed</strong> onto kernel threads</li>
<li>Kernel sees and schedules the kernel threads (a limited number) </li>
<li>User application sees user threads and creates/schedules these (an “unrestricted” number)</li>
</ul>
<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><p><img src="http://ww1.sinaimg.cn/mw690/005P51vHgw1fbinup6cq3j31lq0titm4.jpg" alt=""></p>
<h3 id="Thread-Management"><a href="#Thread-Management" class="headerlink" title="Thread Management"></a>Thread Management</h3><ul>
<li>Thread libraries provide an <strong>API/interface</strong> for managing threads (e.g. creating, running, destroying, synchronising, etc.)</li>
<li>Thread libraries can be implemented:<ul>
<li>Entirely in <strong>user spac</strong>e (i.e. user threads)</li>
<li>Based on <strong>system calls</strong></li>
</ul>
</li>
<li>Examples of thread APIs include <strong>POSIX’s PThreads</strong>, Windows Threads, and Java Threads</li>
<li>The PThread specification can be implemented as user or kernel threads</li>
<li>POSIX threads are a <strong>specification</strong> that “anyone” can implement, i.e., it defines a set of APIs (function calls, over 60 of them) and what they do</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li>Threads vs. processes</li>
<li>Thread implementations (user, kernel and hybrid)</li>
<li>PThreads</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Processes-3&quot;&gt;&lt;a href=&quot;#Processes-3&quot; class=&quot;headerlink&quot; title=&quot;Processes 3&quot;&gt;&lt;/a&gt;Processes 3&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;1 Threads vs. processes&lt;br&gt;2 Different thread implementations&lt;br&gt;3 POSIX Threads (PThreads)&lt;/p&gt;
&lt;h3 id=&quot;Threads&quot;&gt;&lt;a href=&quot;#Threads&quot; class=&quot;headerlink&quot; title=&quot;Threads&quot;&gt;&lt;/a&gt;Threads&lt;/h3&gt;&lt;h4 id=&quot;Threads-from-an-OS-Perspective-观点&quot;&gt;&lt;a href=&quot;#Threads-from-an-OS-Perspective-观点&quot; class=&quot;headerlink&quot; title=&quot;Threads from an OS Perspective[观点]&quot;&gt;&lt;/a&gt;Threads from an OS Perspective[观点]&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;A process consists of two &lt;strong&gt;fundamental units&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Resources:&lt;/strong&gt; all related resources are grouped together&lt;ul&gt;
&lt;li&gt;A logical address space containing the process image (program, data, heap, stack)&lt;/li&gt;
&lt;li&gt;Files, I/O devices, I/O channels, . . .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execution trace&lt;/strong&gt;[执行追踪], i.e., an entity that gets executed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A process can &lt;strong&gt;share its resources&lt;/strong&gt; between &lt;strong&gt;multiple execution traces&lt;/strong&gt;, i.e., multiple threads running in the same resource environment&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/005P51vHgw1fbif3ey9okj317q0oc0yg.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="processes" scheme="http://barondu.com/tags/processes/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Processes2</title>
    <link href="http://barondu.com/2017/01/08/Processes2/"/>
    <id>http://barondu.com/2017/01/08/Processes2/</id>
    <published>2017-01-08T23:26:14.000Z</published>
    <updated>2017-01-08T23:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Processes-2"><a href="#Processes-2" class="headerlink" title="Processes 2"></a>Processes 2</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>Introduction to <strong>process scheduling</strong></li>
<li>Types of <strong>process schedulers</strong></li>
<li><strong>Evaluation criteria</strong> for scheduling algorithms</li>
<li>Typical <strong>process scheduling algorithms</strong></li>
</ul>
<h3 id="Process-Scheduling"><a href="#Process-Scheduling" class="headerlink" title="Process Scheduling"></a>Process Scheduling</h3><p>Context</p>
<ul>
<li>The OS is responsible for <strong>managing</strong> and <strong>scheduling processes</strong><ul>
<li>Decide when to <strong>admit</strong> processes to the system (new → ready)</li>
<li>Decide which process to r<strong>un</strong> next (ready → run)</li>
<li>Decide when and which processes to <strong>interrupt</strong> (running → ready)</li>
</ul>
</li>
<li>It relies on the <strong>scheduler</strong> (dispatcher) to decide which process to run next, which uses a <strong>scheduling algorithm</strong> to do so</li>
<li>The type of algorithm used by the scheduler is influenced by the <strong>type of operating system</strong> (e.g., real time vs. batch)</li>
</ul>
<a id="more"></a>
<p>Classification by Time Horizon</p>
<ul>
<li><strong>Long term</strong>: applies to new processes and controls the degree of multiprogramming by deciding which processes to <strong>admit</strong> to the system<ul>
<li>A good <strong>mix</strong> of <strong>CPU</strong> and <strong>I/O bound processes</strong> is favourable to keep all resources as busy as possible</li>
<li><strong>Usually absent</strong> in popular modern OS</li>
</ul>
</li>
<li><strong>Medium term</strong>: controls <strong>swapping</strong> and the degree of multi-programming </li>
<li><strong>Short term</strong>: decide which process to <strong>run</strong> next<ul>
<li>Usually called in response to <strong>clock interrupts</strong>, <strong>I/O interrupts</strong>, or <strong>blocking system calls</strong></li>
<li>Invoked[调用] very <strong>frequently,</strong> hence must be fast</li>
<li>Manages the <strong>ready queue</strong></li>
</ul>
</li>
</ul>
<p>Classification by Approach</p>
<ul>
<li><strong>Non-preemptive</strong>: processes are only interrupted voluntarily[自愿的] (e.g., I/O operation or “nice” system call – yield())</li>
<li><strong>Preemptive</strong>[优先的]: processes can be <strong>interrupted forcefully</strong> or <strong>voluntarily</strong><ul>
<li>This requires context switches which generate overhead, too many of them should be avoided<br>Prevents processes from <strong>monopolising[垄断的] the CPU</strong></li>
<li><strong>Most popula</strong>r modern operating systems are preemptive</li>
</ul>
</li>
</ul>
<h3 id="Performance-Assessment-性能评估"><a href="#Performance-Assessment-性能评估" class="headerlink" title="Performance Assessment[性能评估]"></a>Performance Assessment[性能评估]</h3><p><strong>User oriented[导向]criteria:</strong></p>
<ul>
<li><strong>Response time:</strong> minimise the time between creating the job and its first execution</li>
<li><strong>Turnaround time</strong>: minimise the time between creating the job and finishing it</li>
<li><strong>Predictability</strong>[可调度性]: minimise the variance[差异，方差] in processing times</li>
</ul>
<p><strong>System oriented criteria:</strong></p>
<ul>
<li><strong>Throughput</strong>[吞吐量]: maximise the number of jobs processed per hour</li>
<li><strong>Fairness</strong>[公平性]:<ul>
<li>Are processing power/waiting time equally distributed?</li>
<li>Are some processes kept waiting excessively long (starvation)</li>
</ul>
</li>
</ul>
<p>Evaluation criteria can be <strong>conflicting</strong>, i.e., <strong>reducing the response time</strong> may i<strong>ncrease context switches</strong> and may <strong>worsen the throughput</strong> and <strong>increase the turn around time</strong></p>
<h3 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h3><p><strong>Algorithms</strong> considered:</p>
<ol>
<li>First Come First Served (<strong>FCFS</strong>)/ First In First Out (<strong>FIFO</strong>)</li>
<li><strong>Shortest job first</strong></li>
<li><strong>Round Robin</strong></li>
<li><strong>Priority queues</strong></li>
</ol>
<p>Performance measures used:</p>
<ul>
<li><strong>Average response time</strong></li>
<li><strong>Average turnaround time</strong></li>
</ul>
<p><code>First Come First Served</code></p>
<ul>
<li>Concept: a <strong>non-preemtive algorithm</strong> that operates as a <strong>strict[严格的] queueing mechanism[机制]</strong> and schedules the processes in the same order that they were added to the queue</li>
<li>Advantages: <strong>positional fairness</strong> and easy to implement </li>
<li>Disadvantages:<ul>
<li><strong>good for long processes</strong> over short ones</li>
<li>Could <strong>compromise[危害] resource utilisation,</strong> i.e., CPU vs. I/O devices<br><img src="http://ww1.sinaimg.cn/mw690/005P51vHgw1fbhgipi0isj31kw0z0gui.jpg" alt="FCFS"></li>
</ul>
</li>
</ul>
<p><code>Shortest Job First</code></p>
<ul>
<li>Concept: A <strong>non-preemtive algorithm</strong> that starts processes in order of <strong>ascending[递增] processing time</strong> using a provided/known estimate of the processing</li>
<li>Advantages: always result in the <strong>good turn around time</strong> </li>
<li>Disadvantages:<ul>
<li><strong>Starvation</strong>[饿死] might occur</li>
<li><strong>Fairness</strong> and <strong>predictability</strong> are compromised </li>
<li><strong>Processing times have to be known</strong> beforehand<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbhgihcb0kj31kw0zaguh.jpg" alt="Shortest Job First"></li>
</ul>
</li>
</ul>
<p><code>Round Robin</code></p>
<ul>
<li>Concept: a <strong>preemptive version of FCFS</strong> that forces <strong>context switches</strong> at <strong>periodic[周期性] intervals[间隔]</strong> or <strong>time slices</strong></li>
<li>Processes run in the order that they were added to the queue </li>
<li>Processes are <strong>forcefully interrupted by the timer</strong><br>Advantages:</li>
<li>Improved <strong>response time</strong></li>
<li><strong>Effective</strong> for general purpose <strong>time sharing systems</strong><br>Disadvantages:</li>
<li>Increased <strong>context switching</strong> and thus overhead</li>
<li><strong>Favours CPU bound processes</strong> (which usually run long) over I/O processes (which do not run long)</li>
<li>Can <strong>reduce to FCFS</strong></li>
</ul>
<p>The length of the time slice must be carefully considered!</p>
<ul>
<li>a <strong>low response time</strong> is achieved with <strong>a small time slice</strong> (e.g. 1ms) ⇒ low throughput</li>
<li>a <strong>high throughput</strong> is achieved with <strong>a large time slice</strong> (e.g. 1000ms) ⇒ high response time</li>
</ul>
<p>If a time slice is only <strong>used</strong> <strong>partially</strong>, the next process <strong>starts immediately</strong><br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbhgilh5rej31kw0ygwnc.jpg" alt="Round Robin"></p>
<p><code>Priority Queues</code></p>
<ul>
<li>Concept: A <strong>preemptive algorithm</strong> that schedules processes by <strong>priority</strong> (high → low)<ul>
<li>The process priority is saved in the <strong>process control block</strong> </li>
</ul>
</li>
<li>Advantages: can <strong>prioritise[优先] I/O bound jobs</strong></li>
<li>Disadvantages: low priority processes may suffer from <strong>starvation</strong> (with static priorities)</li>
<li><img src="http://ww3.sinaimg.cn/mw690/005P51vHgw1fbhgimxagxj31kw0yoths.jpg" alt="Priority Queues"></li>
</ul>
<p>##Summary</p>
<ul>
<li><strong>Types of schedulers</strong>: preemptive/non-preemptive, long/medium/short term)</li>
<li>Performance <strong>evaluation criteria</strong></li>
<li><strong>Scheduling algorithms</strong>: FCFS, SJF, Round Robin, Priority Queues</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Processes-2&quot;&gt;&lt;a href=&quot;#Processes-2&quot; class=&quot;headerlink&quot; title=&quot;Processes 2&quot;&gt;&lt;/a&gt;Processes 2&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Introduction to &lt;strong&gt;process scheduling&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Types of &lt;strong&gt;process schedulers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Evaluation criteria&lt;/strong&gt; for scheduling algorithms&lt;/li&gt;
&lt;li&gt;Typical &lt;strong&gt;process scheduling algorithms&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Process-Scheduling&quot;&gt;&lt;a href=&quot;#Process-Scheduling&quot; class=&quot;headerlink&quot; title=&quot;Process Scheduling&quot;&gt;&lt;/a&gt;Process Scheduling&lt;/h3&gt;&lt;p&gt;Context&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The OS is responsible for &lt;strong&gt;managing&lt;/strong&gt; and &lt;strong&gt;scheduling processes&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Decide when to &lt;strong&gt;admit&lt;/strong&gt; processes to the system (new → ready)&lt;/li&gt;
&lt;li&gt;Decide which process to r&lt;strong&gt;un&lt;/strong&gt; next (ready → run)&lt;/li&gt;
&lt;li&gt;Decide when and which processes to &lt;strong&gt;interrupt&lt;/strong&gt; (running → ready)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It relies on the &lt;strong&gt;scheduler&lt;/strong&gt; (dispatcher) to decide which process to run next, which uses a &lt;strong&gt;scheduling algorithm&lt;/strong&gt; to do so&lt;/li&gt;
&lt;li&gt;The type of algorithm used by the scheduler is influenced by the &lt;strong&gt;type of operating system&lt;/strong&gt; (e.g., real time vs. batch)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="processes" scheme="http://barondu.com/tags/processes/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Processes1</title>
    <link href="http://barondu.com/2017/01/06/Processes1/"/>
    <id>http://barondu.com/2017/01/06/Processes1/</id>
    <published>2017-01-06T11:42:14.000Z</published>
    <updated>2017-01-08T23:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Processes-1"><a href="#Processes-1" class="headerlink" title="Processes 1"></a>Processes 1</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>Introduction to <strong>processes</strong> and their <strong>implementation</strong> </li>
<li>Process <strong>states</strong> and state <strong>transitions</strong></li>
<li><strong>System calls</strong> for process management</li>
</ul>
<h3 id="Processes-and-Implementation"><a href="#Processes-and-Implementation" class="headerlink" title="Processes and Implementation"></a>Processes and Implementation</h3><blockquote>
<p>Definition: <em>“a process is a <strong>running instance</strong> of a program”</em><br><code>进程是程序的运行实例</code></p>
</blockquote>
<ul>
<li>A process is registered with the OS using its “<strong>control structures</strong>”: i.e. an entry in the OS’s <strong>process tab</strong>le to a <strong>process control blocks</strong> (PCB)</li>
<li>The <strong>process control block</strong> contains all information necessary to <strong>manage the process</strong> and is necessary for <strong>context switching</strong> in <strong>multi-programmed systems</strong></li>
<li>A process’ memory image contains:<ul>
<li>The program <strong>code</strong> (could be shared between multiple processes running the same code)</li>
<li>A <strong>data</strong> segment, <strong>stack</strong> and <strong>heap</strong></li>
</ul>
</li>
<li>Every process has its own <strong>logical address</strong> space, in which the stack and heap are placed at opposite[相反的] sides to allow them to grow</li>
</ul>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/mw690/005P51vHgw1fbd6ndp30ij30qo0ns75k.jpg" alt="process’ memory image"></p>
<h3 id="Process-States-and-Transitions"><a href="#Process-States-and-Transitions" class="headerlink" title="Process States and Transitions"></a>Process States and Transitions</h3><p><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbd6yyxrbcj31gk0ts0xg.jpg" alt="Process States and Transitions"><br>Sates:</p>
<ul>
<li>A <strong>new</strong> process has just been created (has a PCB) and is waiting to be admitted (it may not yet be in memory)</li>
<li>A <strong>ready</strong> process is waiting for CPU to become available (e.g. unblocked or timer interrupt)</li>
<li>A <strong>running</strong> process “owns” the CPU</li>
<li>A <strong>blocked</strong> process cannot continue, e.g. is waiting for I/O</li>
<li>A <strong>terminated</strong> process is no longer executable (the data structures - PCB - may be temporarily preserved)</li>
<li>A <strong>suspended</strong>[废除的] process is swapped out[换出] (not discussed further)</li>
</ul>
<p>Transitions：</p>
<ol>
<li><strong>New -&gt; ready</strong>: admit the process and commit to execution</li>
<li><strong>Running -&gt; blocked:</strong> e.g. process is waiting for input or carried out a<br>system call</li>
<li><strong>Ready -&gt; running:</strong> the process is selected by the process scheduler</li>
<li><strong>Blocked -&gt; ready</strong>: event happens, e.g. I/O operation has finished</li>
<li>. <strong>Running -&gt; ready</strong>: the process is preempted, e.g., by a timer interrupt or<br>by pause</li>
<li><strong>Running -&gt;strong text</strong> exit: process has finished, e.g. program ended or exception<br>encountered</li>
</ol>
<p>The interrupts/traps/system calls lie on the basis of the transitions<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbdxkzib3gj31hk0s2n19.jpg" alt="OS queues"></p>
<h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>Multi-programming</p>
<ul>
<li>Modern computers are <strong>multi-programming systems</strong></li>
<li><p>Assuming a single processor system, the instructions of individual processes are executed sequentially</p>
<ul>
<li>Multi-programming goes back to the “<strong>MULTICS</strong>” age </li>
<li>Multi-programming is achieved by <strong>alternating</strong>[交替]processes and <strong>context switching</strong></li>
<li><strong>True parallelism</strong> requires <strong>multiple processors</strong><br><code>并不是真正的multi-programming</code></li>
</ul>
</li>
<li><p>When a <strong>context switch</strong> takes place, the system <strong>saves the state</strong> of the old process and <strong>loads the state</strong> of the new process (creates <strong>overhead</strong>)</p>
<ul>
<li><strong>Saved</strong> -&gt; the process control block is <strong>updated</strong></li>
<li><strong>(Re-)started</strong> -&gt; the process control block <strong>read</strong></li>
</ul>
</li>
<li>A <strong>trade-off</strong>[权衡] exists between the length of the <strong>time-slice</strong> and the <strong>context switch time</strong><ul>
<li><strong>Short time slices</strong> result in <strong>good response times</strong> but <strong>low effective “utilisation”</strong>[使用]<ul>
<li>e.g.: 99*(1+1)=198ms</li>
</ul>
</li>
<li><strong>Long time slices</strong> result in <strong>poor response</strong> times but b<strong>etter effective “utilisation”</strong><ul>
<li>e.g.: 99 * (100 + 1) = 9999ms</li>
</ul>
</li>
</ul>
</li>
<li>A <strong>process control block</strong> contains <strong>three</strong> types of <strong>attributes:</strong><ul>
<li><strong>Process identification</strong> (PID, UID, Parent PID)</li>
<li><strong>Process control information</strong> (process state, scheduling information, etc.) </li>
<li><strong>Process state information</strong> (user registers, program counter, stack pointer, program status word, memory management information, files, etc.)</li>
</ul>
</li>
<li><strong>Process control blocks</strong> are <strong>kernel data structures</strong>, i.e. they are <strong>protected</strong> and only accessible in <strong>kernel mode!</strong><ul>
<li>Allowing user applications to access them directly could <strong>compromise[威胁] their integrity[完整性]</strong></li>
<li>The <strong>operating system manages</strong> them on the user’s behalf through <strong>system calls</strong> (e.g. to set <strong>process priority</strong>)</li>
</ul>
</li>
</ul>
<p>Tables and Control Blocks</p>
<ul>
<li>An operating system <strong>maintains information</strong> about the status of “resources” in <strong>tables</strong><ul>
<li><strong>Process tables</strong> (process control blocks)</li>
<li><strong>Memory tables</strong> (memory allocation, memory protection, virtual memory) </li>
<li><strong>I/O tables</strong> (availability, status, transfer information)</li>
<li><strong>File tables</strong> (location, status)</li>
</ul>
</li>
<li>The <strong>process table</strong> holds a p<strong>rocess control block</strong> for each process, allocated upon <strong>process creation</strong></li>
<li>Tables are maintained by the <strong>kernel</strong> and are usually <strong>cross referenced</strong><br>Switching Processes<blockquote>
<ol>
<li>Save process state (program counter, registers)</li>
<li>Update PCB (running -&gt; ready/blocked)</li>
<li>Move PCB to appropriate queue (ready/blocked)</li>
<li>Run scheduler, select new process</li>
<li>Update to running state in the new PCB</li>
<li>Update memory management unit (MMU)</li>
<li>Restore process</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h3><ul>
<li>System calls are necessary to <strong>notify the OS</strong> that the <strong>process has terminated</strong><ul>
<li>Resources must be de-allocated</li>
<li>Output must be flushed</li>
<li>Process admin may have to be carried out</li>
</ul>
</li>
<li>A system calls for process termination:<ul>
<li>UNIX/Linux: <strong>exit()</strong>, kill() </li>
<li>Windows: <strong>TerminateProcess()</strong></li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li><strong>Definition of a process</strong> and their <strong>implementation</strong> in operating systems </li>
<li><strong>States</strong>, state <strong>transitions</strong> of processes</li>
<li><strong>Kernel structures</strong> for processes and process management</li>
<li><strong>System calls</strong> for process management</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Processes-1&quot;&gt;&lt;a href=&quot;#Processes-1&quot; class=&quot;headerlink&quot; title=&quot;Processes 1&quot;&gt;&lt;/a&gt;Processes 1&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Introduction to &lt;strong&gt;processes&lt;/strong&gt; and their &lt;strong&gt;implementation&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;Process &lt;strong&gt;states&lt;/strong&gt; and state &lt;strong&gt;transitions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System calls&lt;/strong&gt; for process management&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Processes-and-Implementation&quot;&gt;&lt;a href=&quot;#Processes-and-Implementation&quot; class=&quot;headerlink&quot; title=&quot;Processes and Implementation&quot;&gt;&lt;/a&gt;Processes and Implementation&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Definition: &lt;em&gt;“a process is a &lt;strong&gt;running instance&lt;/strong&gt; of a program”&lt;/em&gt;&lt;br&gt;&lt;code&gt;进程是程序的运行实例&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A process is registered with the OS using its “&lt;strong&gt;control structures&lt;/strong&gt;”: i.e. an entry in the OS’s &lt;strong&gt;process tab&lt;/strong&gt;le to a &lt;strong&gt;process control blocks&lt;/strong&gt; (PCB)&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;process control block&lt;/strong&gt; contains all information necessary to &lt;strong&gt;manage the process&lt;/strong&gt; and is necessary for &lt;strong&gt;context switching&lt;/strong&gt; in &lt;strong&gt;multi-programmed systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A process’ memory image contains:&lt;ul&gt;
&lt;li&gt;The program &lt;strong&gt;code&lt;/strong&gt; (could be shared between multiple processes running the same code)&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;data&lt;/strong&gt; segment, &lt;strong&gt;stack&lt;/strong&gt; and &lt;strong&gt;heap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every process has its own &lt;strong&gt;logical address&lt;/strong&gt; space, in which the stack and heap are placed at opposite[相反的] sides to allow them to grow&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="processes" scheme="http://barondu.com/tags/processes/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Introduction2</title>
    <link href="http://barondu.com/2017/01/03/Introduction2/"/>
    <id>http://barondu.com/2017/01/03/Introduction2/</id>
    <published>2017-01-03T23:50:14.000Z</published>
    <updated>2017-01-06T13:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction 2"></a>Introduction 2</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>CPU design</li>
<li><strong>Address spaces, interruts</strong></li>
<li>OS <strong>structures/implementation</strong></li>
</ul>
<h3 id="CPU-design"><a href="#CPU-design" class="headerlink" title="CPU design"></a>CPU design</h3><ul>
<li>A CPU basic cycle consist of <strong>fetch[取], decode, execute</strong></li>
<li>Every CPU has his own <strong>instruction set</strong></li>
<li>CPU has a  set of <strong>registers</strong></li>
<li>Registers are used to store <strong>data</strong> and for <strong>special functions</strong> (e.g. program counter, program status word – mode bit)</li>
<li>The <strong>compiler</strong>/programmer decides what to keep in the registers</li>
<li><strong>Context switching</strong>[上下文切换] must save and restore the CPU’s internal state, including its <strong>registers</strong></li>
</ul>
<a id="more"></a>
<h3 id="Memory-Management-Unit-MMU"><a href="#Memory-Management-Unit-MMU" class="headerlink" title="Memory Management Unit (MMU)"></a>Memory Management Unit (MMU)</h3><ul>
<li>Memory adsresses from 0 to MAX</li>
<li>Variables are <strong>mnemonic</strong>[帮助记忆的] <strong>names</strong> for memory addresses</li>
<li><p>You don’t know where the process will run in <strong>physical memory</strong> at compile time</p>
<ul>
<li><strong>Multiple processes</strong> run on modern machines</li>
<li>The compiler <strong>assumes</strong> that it will start <strong>running at 0 (logical address space)</strong></li>
<li>An <strong>offset</strong>[补偿] is added at runtime by the MMU <strong>(physical address space)</strong><blockquote>
<p>physical address = logical address + offset </p>
</blockquote>
</li>
</ul>
</li>
<li><p>Modern computer use a <strong>logical</strong> and <strong>physical</strong> memory addresses:</p>
<ul>
<li>Every process has a logical address space – [0,<em>MAX64</em>] (theoretically理论上)</li>
<li>The machine has a physical address space – [0, <em>MAX</em> ] (MAX determined by the amount of physical memory)</li>
</ul>
</li>
<li><p><strong>Address translation</strong> takes place in MMU</p>
<blockquote>
<p>physical = f (logical )</p>
</blockquote>
</li>
<li><p>A <strong>context switch</strong> between processes <strong>invalidates</strong>[使无效] the MMU (as well as registers, cache, … )</p>
</li>
</ul>
<h3 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h3><ul>
<li>Interrupts <strong>temporarily pause</strong> a process’s normal operation</li>
<li>Different types of interrupts:<ul>
<li>Timer interrupts by <strong>CPU clock</strong></li>
<li><strong>I/O interrupts</strong> for I/O completion or error codes </li>
<li><strong>Software generated</strong>, e.g. errors and exceptions<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbd1p9u5baj31ea0d80us.jpg" alt=""><blockquote>
<ol>
<li>Timer generates an interrupt</li>
<li>CPU finishes current instruction and tests for interrupt</li>
<li>Transfer to interrupt service routine</li>
</ol>
<ul>
<li>Hardware saves current process state (PSW, program counter)</li>
<li>Set program counter to interrupt service routine</li>
<li>Save registers and other state information</li>
</ul>
<ol>
<li>Carry out[执行] interrupt service routine (scheduler)</li>
<li>Restore next process to run</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Moore’s-“law”"><a href="#Moore’s-“law”" class="headerlink" title="Moore’s “law”"></a>Moore’s “law”</h3><blockquote>
<p><strong>Moore’s “law”:</strong>  “The number of transistors on an integrated circuit (chip) doubles roughly every two years” </p>
</blockquote>
<ul>
<li>Closely linked, but not necessarily related to performance</li>
<li>The <strong>“power wall”</strong> slows performance improvements of single core/single processor systems<ul>
<li>A few cores for multiple “programs” is easy to justify</li>
<li>How to use <strong>massively[大规模的] parallel</strong> computers/CPUs/many core machines </li>
<li>Can we <strong>extract parallelism automatically</strong>, can we implement parallelism at the lowest level (similar to multiprogramming) </li>
</ul>
</li>
</ul>
<h3 id="Multi-core-hyperthreaded-processors"><a href="#Multi-core-hyperthreaded-processors" class="headerlink" title="Multi-core, hyperthreaded processors"></a>Multi-core, hyperthreaded processors</h3><ul>
<li>Modern CPUs contain <strong>multiple cores</strong> and are often <strong>hyper-threaded</strong> </li>
<li><strong>Evolution in hardware</strong> has implications on operating system design<ul>
<li>XP did not support multi processor architectures</li>
<li><strong>Process scheduling</strong> needs to account for <strong>load balancing</strong> and <strong>CPU affinity</strong>[亲和性]</li>
<li><strong>Cache coherency</strong>[缓存一致性] becomes important</li>
</ul>
</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul>
<li>Memory <strong>hierarchies</strong>[层级] used to balance <strong>cost</strong> and <strong>performance</strong> <ul>
<li>Fast and expensive memory is used for <strong>caching</strong></li>
<li>Slow and inexpensive memory is used for <strong>long term storage</strong></li>
<li>Memory includes, registers, L1/L2 cache, main/core memory, disk, etc.</li>
<li><strong>L2 Cache</strong> can be <strong>shared</strong> or <strong>dedicated</strong>[专注的] to individual cores </li>
<li><strong>Cache management</strong> is mainly done by <strong>hardware</strong></li>
<li>The CPU can only <strong>access main memory directly</strong> (i.e. files have to be brought into memory first)</li>
</ul>
</li>
</ul>
<h3 id="I-O-Devices"><a href="#I-O-Devices" class="headerlink" title="I/O Devices"></a>I/O Devices</h3><ul>
<li><strong>Device driver</strong> interacts[交互] with the <strong>controller</strong>, controller interacts with the device (e.g., disk controller)</li>
<li>The operating system/device driver typically <strong>communicates with the controller through registers</strong></li>
<li>I/O can take place through:<ul>
<li><strong>Busy waiting</strong></li>
<li><strong>Interrupt based</strong></li>
<li>Direct memory access (using <strong>DMA</strong> chip)</li>
</ul>
</li>
</ul>
<h3 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h3><ul>
<li>Systems contain a lot of functionality</li>
<li>Operating Systems are structured by <strong>Micro kernels</strong>[微内核] and <strong>Monolithic</strong>[单内核]</li>
</ul>
<h3 id="Micro-Kernels"><a href="#Micro-Kernels" class="headerlink" title="Micro Kernels"></a>Micro Kernels</h3><ul>
<li>All <strong>non-essential functionality</strong> is <strong>extracted</strong>[取出] from the kernel <ul>
<li><strong>Communication, memory management</strong> and <strong>CPU scheduling</strong> are likely to be included in the kernel</li>
<li><strong>The file system, GUI, device drivers</strong> are likely to be user processes<br><code>除了保留基本功能，其他功能移出到user mode</code></li>
</ul>
</li>
<li>Micro kernels are more <strong>easy to extend</strong>, more <strong>portable</strong>[便携], and usually more reliable</li>
<li>Frequent <strong>system calls</strong> and <strong>kernel traps</strong>[陷阱] cause significant <strong>overhead</strong>[开销] (mode switches)</li>
<li>Some Unix version, Mac OS X, Minix, and early versions of Windows (NT4.0) were (partially) micro kernels</li>
</ul>
<h3 id="Monolithic-Systems"><a href="#Monolithic-Systems" class="headerlink" title="Monolithic Systems"></a>Monolithic Systems</h3><ul>
<li>All procedures are <strong>linked together</strong> into one <strong>single executable running</strong> in <strong>kernel mode</strong></li>
<li>Monolithic kernels are <strong>difficult to maintain</strong></li>
<li>Current versions of Windows, Linux are implemented as monolithic kernels<br><code>操作系统高度紧密，移植性不佳。但是若设计完善，效率高</code></li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Operating Systems are closely linked to <strong>computer architecture</strong> </li>
<li><strong>Address translation</strong> and <strong>interrupts</strong></li>
<li><strong>OS structures</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction-2&quot;&gt;&lt;a href=&quot;#Introduction-2&quot; class=&quot;headerlink&quot; title=&quot;Introduction 2&quot;&gt;&lt;/a&gt;Introduction 2&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU design&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address spaces, interruts&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS &lt;strong&gt;structures/implementation&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CPU-design&quot;&gt;&lt;a href=&quot;#CPU-design&quot; class=&quot;headerlink&quot; title=&quot;CPU design&quot;&gt;&lt;/a&gt;CPU design&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A CPU basic cycle consist of &lt;strong&gt;fetch[取], decode, execute&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Every CPU has his own &lt;strong&gt;instruction set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CPU has a  set of &lt;strong&gt;registers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Registers are used to store &lt;strong&gt;data&lt;/strong&gt; and for &lt;strong&gt;special functions&lt;/strong&gt; (e.g. program counter, program status word – mode bit)&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;compiler&lt;/strong&gt;/programmer decides what to keep in the registers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context switching&lt;/strong&gt;[上下文切换] must save and restore the CPU’s internal state, including its &lt;strong&gt;registers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="Introduction" scheme="http://barondu.com/tags/Introduction/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Introduction1</title>
    <link href="http://barondu.com/2017/01/01/Introduction1/"/>
    <id>http://barondu.com/2017/01/01/Introduction1/</id>
    <published>2017-01-01T15:06:04.000Z</published>
    <updated>2017-01-06T13:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction 1"></a>Introduction 1</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>“<strong>Defining</strong>“ operating systems</li>
<li>What is <strong>multi-programming</strong></li>
<li><strong>Kernel-user mode</strong></li>
</ul>
<h3 id="Defining-Operating-Systems"><a href="#Defining-Operating-Systems" class="headerlink" title="Defining Operating Systems"></a>Defining Operating Systems</h3><ul>
<li><p>In the early days, programmers had to <strong>deal directly with hardware</strong></p>
<ul>
<li>Real computer <strong>hardware is urgly</strong></li>
<li>Hardware is <strong>extremely difficult</strong> to program</li>
</ul>
</li>
<li><p>An operating system is a layer[层] of indirection[间接] on top of the hardware:</p>
<ul>
<li>It provide <strong>abstractions</strong> for application programs</li>
<li>it provide a <strong>cleaner and easier interface to the hardware</strong></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="Multi-programming"><a href="#Multi-programming" class="headerlink" title="Multi-programming"></a>Multi-programming</h3><ul>
<li>Morden OS use <strong>multi-programming</strong> to <strong>improve user experience</strong> and <strong>maximise the use of resource</strong><ul>
<li>Disk is <strong>slow</strong>. CPU is <strong>faster</strong> than disk. </li>
<li>Without multi-programming, CPU time is <strong>waste</strong> while wating for I/O requests.</li>
<li><strong>Multi-programming</strong> has important <strong>consequences[结果]</strong> for operating system design </li>
</ul>
</li>
<li>The operating system must allocate[分配]/share resources (CPU, memory, I/O devices) <strong>fairly</strong> and <strong>safely</strong> between competing processes:<ul>
<li>In time, e.g. CPUs and printers </li>
<li>In space, e.g., memory and disks</li>
</ul>
</li>
<li>The execution of <strong>multiple programs</strong> (processes) needs to be interleaved[交错] with one another. This requires:<ul>
<li>This requires <strong>context switches</strong> and <strong>process scheduling</strong> ⇒ <strong>mutual exclusion[相互排斥]</strong>, <strong>deadlock avoidance</strong>, <strong>protection</strong>, . . .</li>
</ul>
</li>
</ul>
<h3 id="Kernel-user-mode"><a href="#Kernel-user-mode" class="headerlink" title="Kernel-user mode"></a>Kernel-user mode</h3><ul>
<li>Modern operating systems have multiple <strong>modes</strong>:<ul>
<li>The operating system runs in <strong>kernel mode</strong> and has access to <strong>all instructions</strong></li>
<li>Applications run in <strong>user mode</strong> and have access to <strong>a subset of instructions</strong></li>
</ul>
</li>
<li>Transitions from user mode to kernel mode happen in a controlled manner (<strong>interrupts, exceptions, system calls</strong>) and are <strong>mirrored in hardware</strong></li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Some properties:<ul>
<li>Sits <strong>directly</strong> on <strong>top</strong> of the hardware</li>
<li>Has access to the <strong>full capabilities of the hardware</strong></li>
<li>Provides <strong>abstractions</strong> for the user/programmer</li>
<li>Makes sure that everything is <strong>organised</strong> and runs in <strong>order</strong>     </li>
<li>Improve the <strong>hardware interface</strong></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction-1&quot;&gt;&lt;a href=&quot;#Introduction-1&quot; class=&quot;headerlink&quot; title=&quot;Introduction 1&quot;&gt;&lt;/a&gt;Introduction 1&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;“&lt;strong&gt;Defining&lt;/strong&gt;“ operating systems&lt;/li&gt;
&lt;li&gt;What is &lt;strong&gt;multi-programming&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel-user mode&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Defining-Operating-Systems&quot;&gt;&lt;a href=&quot;#Defining-Operating-Systems&quot; class=&quot;headerlink&quot; title=&quot;Defining Operating Systems&quot;&gt;&lt;/a&gt;Defining Operating Systems&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the early days, programmers had to &lt;strong&gt;deal directly with hardware&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Real computer &lt;strong&gt;hardware is urgly&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Hardware is &lt;strong&gt;extremely difficult&lt;/strong&gt; to program&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An operating system is a layer[层] of indirection[间接] on top of the hardware:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It provide &lt;strong&gt;abstractions&lt;/strong&gt; for application programs&lt;/li&gt;
&lt;li&gt;it provide a &lt;strong&gt;cleaner and easier interface to the hardware&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="Introduction" scheme="http://barondu.com/tags/Introduction/"/>
    
  </entry>
  
</feed>
