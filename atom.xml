<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Baron的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://barondu.com/"/>
  <updated>2017-01-06T18:49:09.000Z</updated>
  <id>http://barondu.com/</id>
  
  <author>
    <name>Baron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记 OSC_Processes1</title>
    <link href="http://barondu.com/2017/01/06/Processes1/"/>
    <id>http://barondu.com/2017/01/06/Processes1/</id>
    <published>2017-01-06T11:42:14.000Z</published>
    <updated>2017-01-06T18:49:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Processes-1"><a href="#Processes-1" class="headerlink" title="Processes 1"></a>Processes 1</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>Introduction to <strong>processes</strong> and their <strong>implementation</strong> </li>
<li>Process <strong>states</strong> and state <strong>transitions</strong></li>
<li><strong>System calls</strong> for process management</li>
</ul>
<h3 id="Processes-and-Implementation"><a href="#Processes-and-Implementation" class="headerlink" title="Processes and Implementation"></a>Processes and Implementation</h3><blockquote>
<p>Definition: <em>“a process is a <strong>running instance</strong> of a program”</em><br><code>进程是程序的运行实例</code></p>
</blockquote>
<ul>
<li>A process is registered with the OS using its “<strong>control structures</strong>”: i.e. an entry in the OS’s <strong>process tab</strong>le to a <strong>process control blocks</strong> (PCB)</li>
<li>The <strong>process control bloc</strong>k contains all information necessary to <strong>manage the process</strong> and is necessary for <strong>context switching</strong> in <strong>multi-programmed systems</strong></li>
<li>A process’ memory image contains:<ul>
<li>The program <strong>code</strong> (could be shared between multiple processes running the same code)</li>
<li>A <strong>data</strong> segment, <strong>stack</strong> and <strong>heap</strong></li>
</ul>
</li>
<li>Every process has its own l<strong>ogical address</strong> space, in which the stack and heap are placed at opposite[相反的] sides to allow them to grow<br><img src="http://ww3.sinaimg.cn/mw690/005P51vHgw1fbd6ndp30ij30qo0ns75k.jpg" alt="process’ memory image"></li>
</ul>
<a id="more"></a>
<h3 id="Process-States-and-Transitions"><a href="#Process-States-and-Transitions" class="headerlink" title="Process States and Transitions"></a>Process States and Transitions</h3><p><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbd6yyxrbcj31gk0ts0xg.jpg" alt="Process States and Transitions"><br>Sates:</p>
<ul>
<li>A <strong>new</strong> process has just been created (has a PCB) and is waiting to be admitted (it may not yet be in memory)</li>
<li>A <strong>ready</strong> process is waiting for CPU to become available (e.g. unblocked or timer interrupt)</li>
<li>A <strong>running</strong> process “owns” the CPU</li>
<li>A <strong>blocked</strong> process cannot continue, e.g. is waiting for I/O</li>
<li>A <strong>terminated</strong> process is no longer executable (the data structures - PCB - may be temporarily preserved)</li>
<li>A <strong>suspended</strong>[废除的] process is swapped out[换出] (not discussed further)</li>
</ul>
<p>Transitions：</p>
<ol>
<li><strong>New -&gt; ready</strong>: admit the process and commit to execution</li>
<li><strong>Running -&gt; blocked:</strong> e.g. process is waiting for input or carried out a<br>system call</li>
<li><strong>Ready -&gt; running:</strong> the process is selected by the process scheduler</li>
<li><strong>Blocked -&gt; ready</strong>: event happens, e.g. I/O operation has finished</li>
<li>. <strong>Running -&gt; ready</strong>: the process is preempted, e.g., by a timer interrupt or<br>by pause</li>
<li><strong>Running -&gt;strong text</strong> exit: process has finished, e.g. program ended or exception<br>encountered</li>
</ol>
<p>The interrupts/traps/system calls lie on the basis of the transitions<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbdxkzib3gj31hk0s2n19.jpg" alt="OS queues"></p>
<h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>Multi-programming</p>
<ul>
<li>Modern computers are <strong>multi-programming systems</strong></li>
<li><p>Assuming a single processor system, the instructions of individual processes are executed sequentially</p>
<ul>
<li>Multi-programming goes back to the “<strong>MULTICS</strong>” age </li>
<li>Multi-programming is achieved by <strong>alternating</strong>[交替]processes and <strong>context switching</strong></li>
<li><strong>True parallelism</strong> requires <strong>multiple processors</strong><br><code>并不是真正的multi-programming</code></li>
</ul>
</li>
<li><p>When a <strong>context switch</strong> takes place, the system <strong>saves the state</strong> of the old process and <strong>loads the state</strong> of the new process (creates <strong>overhead</strong>)</p>
<ul>
<li><strong>Saved</strong> -&gt; the process control block is <strong>updated</strong></li>
<li><strong>(Re-)started</strong> -&gt; the process control block <strong>read</strong></li>
</ul>
</li>
<li>A <strong>trade-off</strong>[权衡] exists between the length of the <strong>time-slice</strong> and the <strong>context switch time</strong><ul>
<li><strong>Short time slices</strong> result in <strong>good response times</strong> but <strong>low effective “utilisation”</strong>[使用]<ul>
<li>e.g.: 99*(1+1)=198ms</li>
</ul>
</li>
<li><strong>Long time slices</strong> result in <strong>poor response</strong> times but b<strong>etter effective “utilisation”</strong><ul>
<li>e.g.: 99 * (100 + 1) = 9999ms</li>
</ul>
</li>
</ul>
</li>
<li>A <strong>process control block</strong> contains <strong>three</strong> types of <strong>attributes:</strong><ul>
<li><strong>Process identification</strong> (PID, UID, Parent PID)</li>
<li><strong>Process control information</strong> (process state, scheduling information, etc.) </li>
<li><strong>Process state information</strong> (user registers, program counter, stack pointer, program status word, memory management information, files, etc.)</li>
</ul>
</li>
<li><strong>Process control blocks</strong> are <strong>kernel data structures</strong>, i.e. they are <strong>protected</strong> and only accessible in <strong>kernel mode!</strong><ul>
<li>Allowing user applications to access them directly could <strong>compromise[威胁] their integrity[完整性]</strong></li>
<li>The <strong>operating system manages</strong> them on the user’s behalf through <strong>system calls</strong> (e.g. to set <strong>process priority</strong>)</li>
</ul>
</li>
</ul>
<p>Tables and Control Blocks</p>
<ul>
<li>An operating system <strong>maintains information</strong> about the status of “resources” in <strong>tables</strong><ul>
<li><strong>Process tables</strong> (process control blocks)</li>
<li><strong>Memory tables</strong> (memory allocation, memory protection, virtual memory) </li>
<li><strong>I/O tables</strong> (availability, status, transfer information)</li>
<li><strong>File tables</strong> (location, status)</li>
</ul>
</li>
<li>The <strong>process tabl</strong>e holds a p<strong>rocess control block</strong> for each process, allocated upon <strong>process creation</strong></li>
<li>Tables are maintained by the <strong>kernel</strong> and are usually <strong>cross referenced</strong><br>Switching Processes<blockquote>
<ol>
<li>Save process state (program counter, registers)</li>
<li>Update PCB (running -&gt; ready/blocked)</li>
<li>Move PCB to appropriate queue (ready/blocked)</li>
<li>Run scheduler, select new process</li>
<li>Update to running state in the new PCB</li>
<li>Update memory management unit (MMU)</li>
<li>Restore process</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h3><ul>
<li>System calls are necessary to <strong>notify the OS</strong> that the <strong>process has terminated</strong><ul>
<li>Resources must be de-allocated</li>
<li>Output must be flushed</li>
<li>Process admin may have to be carried out</li>
</ul>
</li>
<li>A system calls for process termination:<ul>
<li>UNIX/Linux: <strong>exit()</strong>, kill() </li>
<li>Windows: <strong>TerminateProcess()</strong></li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li><strong>Definition of a process</strong> and their <strong>implementation</strong> in operating systems </li>
<li><strong>States</strong>, state <strong>transitions</strong> of processes</li>
<li><strong>Kernel structures</strong> for processes and process management</li>
<li><strong>System calls</strong> for process management</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Processes-1&quot;&gt;&lt;a href=&quot;#Processes-1&quot; class=&quot;headerlink&quot; title=&quot;Processes 1&quot;&gt;&lt;/a&gt;Processes 1&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Introduction to &lt;strong&gt;processes&lt;/strong&gt; and their &lt;strong&gt;implementation&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;Process &lt;strong&gt;states&lt;/strong&gt; and state &lt;strong&gt;transitions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System calls&lt;/strong&gt; for process management&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Processes-and-Implementation&quot;&gt;&lt;a href=&quot;#Processes-and-Implementation&quot; class=&quot;headerlink&quot; title=&quot;Processes and Implementation&quot;&gt;&lt;/a&gt;Processes and Implementation&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Definition: &lt;em&gt;“a process is a &lt;strong&gt;running instance&lt;/strong&gt; of a program”&lt;/em&gt;&lt;br&gt;&lt;code&gt;进程是程序的运行实例&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A process is registered with the OS using its “&lt;strong&gt;control structures&lt;/strong&gt;”: i.e. an entry in the OS’s &lt;strong&gt;process tab&lt;/strong&gt;le to a &lt;strong&gt;process control blocks&lt;/strong&gt; (PCB)&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;process control bloc&lt;/strong&gt;k contains all information necessary to &lt;strong&gt;manage the process&lt;/strong&gt; and is necessary for &lt;strong&gt;context switching&lt;/strong&gt; in &lt;strong&gt;multi-programmed systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A process’ memory image contains:&lt;ul&gt;
&lt;li&gt;The program &lt;strong&gt;code&lt;/strong&gt; (could be shared between multiple processes running the same code)&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;data&lt;/strong&gt; segment, &lt;strong&gt;stack&lt;/strong&gt; and &lt;strong&gt;heap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every process has its own l&lt;strong&gt;ogical address&lt;/strong&gt; space, in which the stack and heap are placed at opposite[相反的] sides to allow them to grow&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/005P51vHgw1fbd6ndp30ij30qo0ns75k.jpg&quot; alt=&quot;process’ memory image&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="processes" scheme="http://barondu.com/tags/processes/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Introduction2</title>
    <link href="http://barondu.com/2017/01/03/Introduction2/"/>
    <id>http://barondu.com/2017/01/03/Introduction2/</id>
    <published>2017-01-03T23:50:14.000Z</published>
    <updated>2017-01-06T13:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction 2"></a>Introduction 2</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>CPU design</li>
<li><strong>Address spaces, interruts</strong></li>
<li>OS <strong>structures/implementation</strong></li>
</ul>
<h3 id="CPU-design"><a href="#CPU-design" class="headerlink" title="CPU design"></a>CPU design</h3><ul>
<li>A CPU basic cycle consist of <strong>fetch[取], decode, execute</strong></li>
<li>Every CPU has his own <strong>instruction set</strong></li>
<li>CPU has a  set of <strong>registers</strong></li>
<li>Registers are used to store <strong>data</strong> and for <strong>special functions</strong> (e.g. program counter, program status word – mode bit)</li>
<li>The <strong>compiler</strong>/programmer decides what to keep in the registers</li>
<li><strong>Context switching</strong>[上下文切换] must save and restore the CPU’s internal state, including its <strong>registers</strong></li>
</ul>
<a id="more"></a>
<h3 id="Memory-Management-Unit-MMU"><a href="#Memory-Management-Unit-MMU" class="headerlink" title="Memory Management Unit (MMU)"></a>Memory Management Unit (MMU)</h3><ul>
<li>Memory adsresses from 0 to MAX</li>
<li>Variables are <strong>mnemonic</strong>[帮助记忆的] <strong>names</strong> for memory addresses</li>
<li><p>You don’t know where the process will run in <strong>physical memory</strong> at compile time</p>
<ul>
<li><strong>Multiple processes</strong> run on modern machines</li>
<li>The compiler <strong>assumes</strong> that it will start <strong>running at 0 (logical address space)</strong></li>
<li>An <strong>offset</strong>[补偿] is added at runtime by the MMU <strong>(physical address space)</strong><blockquote>
<p>physical address = logical address + offset </p>
</blockquote>
</li>
</ul>
</li>
<li><p>Modern computer use a <strong>logical</strong> and <strong>physical</strong> memory addresses:</p>
<ul>
<li>Every process has a logical address space – [0,<em>MAX64</em>] (theoretically理论上)</li>
<li>The machine has a physical address space – [0, <em>MAX</em> ] (MAX determined by the amount of physical memory)</li>
</ul>
</li>
<li><p><strong>Address translation</strong> takes place in MMU</p>
<blockquote>
<p>physical = f (logical )</p>
</blockquote>
</li>
<li><p>A <strong>context switch</strong> between processes <strong>invalidates</strong>[使无效] the MMU (as well as registers, cache, … )</p>
</li>
</ul>
<h3 id="Timer-interrupts"><a href="#Timer-interrupts" class="headerlink" title="Timer interrupts"></a>Timer interrupts</h3><ul>
<li>Interrupts <strong>temporarily pause</strong> a process’s normal operation</li>
<li>Different types of interrupts:<ul>
<li>Timer interrupts by <strong>CPU clock</strong></li>
<li><strong>I/O interrupts</strong> for I/O completion or error codes </li>
<li><strong>Software generated</strong>, e.g. errors and exceptions<br><img src="http://ww2.sinaimg.cn/mw690/005P51vHgw1fbd1p9u5baj31ea0d80us.jpg" alt=""><blockquote>
<ol>
<li>Timer generates an interrupt</li>
<li>CPU finishes current instruction and tests for interrupt</li>
<li>Transfer to interrupt service routine</li>
</ol>
<ul>
<li>Hardware saves current process state (PSW, program counter)</li>
<li>Set program counter to interrupt service routine</li>
<li>Save registers and other state information</li>
</ul>
<ol>
<li>Carry out[执行] interrupt service routine (scheduler)</li>
<li>Restore next process to run</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Moore’s-“law”"><a href="#Moore’s-“law”" class="headerlink" title="Moore’s “law”"></a>Moore’s “law”</h3><blockquote>
<p><strong>Moore’s “law”:</strong>  “The number of transistors on an integrated circuit (chip) doubles roughly every two years” </p>
</blockquote>
<ul>
<li>Closely linked, but not necessarily related to performance</li>
<li>The <strong>“power wall”</strong> slows performance improvements of single core/single processor systems<ul>
<li>A few cores for multiple “programs” is easy to justify</li>
<li>How to use <strong>massively[大规模的] parallel</strong> computers/CPUs/many core machines </li>
<li>Can we <strong>extract parallelism automatically</strong>, can we implement parallelism at the lowest level (similar to multiprogramming) </li>
</ul>
</li>
</ul>
<h3 id="Multi-core-hyperthreaded-processors"><a href="#Multi-core-hyperthreaded-processors" class="headerlink" title="Multi-core, hyperthreaded processors"></a>Multi-core, hyperthreaded processors</h3><ul>
<li>Modern CPUs contain <strong>multiple cores</strong> and are often <strong>hyper-threaded</strong> </li>
<li><strong>Evolution in hardware</strong> has implications on operating system design<ul>
<li>XP did not support multi processor architectures</li>
<li><strong>Process scheduling</strong> needs to account for <strong>load balancing</strong> and <strong>CPU affinity</strong>[亲和性]</li>
<li><strong>Cache coherency</strong>[缓存一致性] becomes important</li>
</ul>
</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul>
<li>Memory <strong>hierarchies</strong>[层级] used to balance <strong>cost</strong> and <strong>performance</strong> <ul>
<li>Fast and expensive memory is used for <strong>caching</strong></li>
<li>Slow and inexpensive memory is used for <strong>long term storage</strong></li>
<li>Memory includes, registers, L1/L2 cache, main/core memory, disk, etc.</li>
<li><strong>L2 Cache</strong> can be <strong>shared</strong> or <strong>dedicated</strong>[专注的] to individual cores </li>
<li><strong>Cache management</strong> is mainly done by <strong>hardware</strong></li>
<li>The CPU can only <strong>access main memory directly</strong> (i.e. files have to be brought into memory first)</li>
</ul>
</li>
</ul>
<h3 id="I-O-Devices"><a href="#I-O-Devices" class="headerlink" title="I/O Devices"></a>I/O Devices</h3><ul>
<li><strong>Device driver</strong> interacts[交互] with the <strong>controller</strong>, controller interacts with the device (e.g., disk controller)</li>
<li>The operating system/device driver typically <strong>communicates with the controller through registers</strong></li>
<li>I/O can take place through:<ul>
<li><strong>Busy waiting</strong></li>
<li><strong>Interrupt based</strong></li>
<li>Direct memory access (using <strong>DMA</strong> chip)</li>
</ul>
</li>
</ul>
<h3 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h3><ul>
<li>Systems contain a lot of functionality</li>
<li>Operating Systems are structured by <strong>Micro kernels</strong>[微内核] and <strong>Monolithic</strong>[单内核]</li>
</ul>
<h3 id="Micro-Kernels"><a href="#Micro-Kernels" class="headerlink" title="Micro Kernels"></a>Micro Kernels</h3><ul>
<li>All <strong>non-essential functionality</strong> is <strong>extracted</strong>[取出] from the kernel <ul>
<li><strong>Communication, memory management</strong> and <strong>CPU scheduling</strong> are likely to be included in the kernel</li>
<li><strong>The file system, GUI, device drivers</strong> are likely to be user processes<br><code>除了保留基本功能，其他功能移出到user mode</code></li>
</ul>
</li>
<li>Micro kernels are more <strong>easy to extend</strong>, more <strong>portable</strong>[便携], and usually more reliable</li>
<li>Frequent <strong>system calls</strong> and <strong>kernel traps</strong>[陷阱] cause significant <strong>overhead</strong>[开销] (mode switches)</li>
<li>Some Unix version, Mac OS X, Minix, and early versions of Windows (NT4.0) were (partially) micro kernels</li>
</ul>
<h3 id="Monolithic-Systems"><a href="#Monolithic-Systems" class="headerlink" title="Monolithic Systems"></a>Monolithic Systems</h3><ul>
<li>All procedures are <strong>linked together</strong> into one <strong>single executable running</strong> in <strong>kernel mode</strong></li>
<li>Monolithic kernels are <strong>difficult to maintain</strong></li>
<li>Current versions of Windows, Linux are implemented as monolithic kernels<br><code>操作系统高度紧密，移植性不佳。但是若设计完善，效率高</code></li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Operating Systems are closely linked to <strong>computer architecture</strong> </li>
<li><strong>Address translation</strong> and <strong>interrupts</strong></li>
<li><strong>OS structures</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction-2&quot;&gt;&lt;a href=&quot;#Introduction-2&quot; class=&quot;headerlink&quot; title=&quot;Introduction 2&quot;&gt;&lt;/a&gt;Introduction 2&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU design&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address spaces, interruts&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS &lt;strong&gt;structures/implementation&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CPU-design&quot;&gt;&lt;a href=&quot;#CPU-design&quot; class=&quot;headerlink&quot; title=&quot;CPU design&quot;&gt;&lt;/a&gt;CPU design&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A CPU basic cycle consist of &lt;strong&gt;fetch[取], decode, execute&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Every CPU has his own &lt;strong&gt;instruction set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CPU has a  set of &lt;strong&gt;registers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Registers are used to store &lt;strong&gt;data&lt;/strong&gt; and for &lt;strong&gt;special functions&lt;/strong&gt; (e.g. program counter, program status word – mode bit)&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;compiler&lt;/strong&gt;/programmer decides what to keep in the registers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context switching&lt;/strong&gt;[上下文切换] must save and restore the CPU’s internal state, including its &lt;strong&gt;registers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="Introduction" scheme="http://barondu.com/tags/Introduction/"/>
    
  </entry>
  
  <entry>
    <title>笔记 OSC_Introduction1</title>
    <link href="http://barondu.com/2017/01/01/Introduction1/"/>
    <id>http://barondu.com/2017/01/01/Introduction1/</id>
    <published>2017-01-01T15:06:04.000Z</published>
    <updated>2017-01-06T13:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction 1"></a>Introduction 1</h1><hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>“<strong>Defining</strong>“ operating systems</li>
<li>What is <strong>multi-programming</strong></li>
<li><strong>Kernel-user mode</strong></li>
</ul>
<h3 id="Defining-Operating-Systems"><a href="#Defining-Operating-Systems" class="headerlink" title="Defining Operating Systems"></a>Defining Operating Systems</h3><ul>
<li><p>In the early days, programmers had to <strong>deal directly with hardware</strong></p>
<ul>
<li>Real computer <strong>hardware is urgly</strong></li>
<li>Hardware is <strong>extremely difficult</strong> to program</li>
</ul>
</li>
<li><p>An operating system is a layer[层] of indirection[间接] on top of the hardware:</p>
<ul>
<li>It provide <strong>abstractions</strong> for application programs</li>
<li>it provide a <strong>cleaner and easier interface to the hardware</strong></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="Multi-programming"><a href="#Multi-programming" class="headerlink" title="Multi-programming"></a>Multi-programming</h3><ul>
<li>Morden OS use <strong>multi-programming</strong> to <strong>improve user experience</strong> and <strong>maximise the use of resource</strong><ul>
<li>Disk is <strong>slow</strong>. CPU is <strong>faster</strong> than disk. </li>
<li>Without multi-programming, CPU time is <strong>waste</strong> while wating for I/O requests.</li>
<li><strong>Multi-programming</strong> has important <strong>consequences[结果]</strong> for operating system design </li>
</ul>
</li>
<li>The operating system must allocate[分配]/share resources (CPU, memory, I/O devices) <strong>fairly</strong> and <strong>safely</strong> between competing processes:<ul>
<li>In time, e.g. CPUs and printers </li>
<li>In space, e.g., memory and disks</li>
</ul>
</li>
<li>The execution of <strong>multiple programs</strong> (processes) needs to be interleaved[交错] with one another. This requires:<ul>
<li>This requires <strong>context switches</strong> and <strong>process scheduling</strong> ⇒ <strong>mutual exclusion[相互排斥]</strong>, <strong>deadlock avoidance</strong>, <strong>protection</strong>, . . .</li>
</ul>
</li>
</ul>
<h3 id="Kernel-user-mode"><a href="#Kernel-user-mode" class="headerlink" title="Kernel-user mode"></a>Kernel-user mode</h3><ul>
<li>Modern operating systems have multiple <strong>modes</strong>:<ul>
<li>The operating system runs in <strong>kernel mode</strong> and has access to <strong>all instructions</strong></li>
<li>Applications run in <strong>user mode</strong> and have access to <strong>a subset of instructions</strong></li>
</ul>
</li>
<li>Transitions from user mode to kernel mode happen in a controlled manner (<strong>interrupts, exceptions, system calls</strong>) and are <strong>mirrored in hardware</strong></li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Some properties:<ul>
<li>Sits <strong>directly</strong> on <strong>top</strong> of the hardware</li>
<li>Has access to the <strong>full capabilities of the hardware</strong></li>
<li>Provides <strong>abstractions</strong> for the user/programmer</li>
<li>Makes sure that everything is <strong>organised</strong> and runs in <strong>order</strong>     </li>
<li>Improve the <strong>hardware interface</strong></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Introduction-1&quot;&gt;&lt;a href=&quot;#Introduction-1&quot; class=&quot;headerlink&quot; title=&quot;Introduction 1&quot;&gt;&lt;/a&gt;Introduction 1&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;“&lt;strong&gt;Defining&lt;/strong&gt;“ operating systems&lt;/li&gt;
&lt;li&gt;What is &lt;strong&gt;multi-programming&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel-user mode&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Defining-Operating-Systems&quot;&gt;&lt;a href=&quot;#Defining-Operating-Systems&quot; class=&quot;headerlink&quot; title=&quot;Defining Operating Systems&quot;&gt;&lt;/a&gt;Defining Operating Systems&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the early days, programmers had to &lt;strong&gt;deal directly with hardware&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Real computer &lt;strong&gt;hardware is urgly&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Hardware is &lt;strong&gt;extremely difficult&lt;/strong&gt; to program&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An operating system is a layer[层] of indirection[间接] on top of the hardware:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It provide &lt;strong&gt;abstractions&lt;/strong&gt; for application programs&lt;/li&gt;
&lt;li&gt;it provide a &lt;strong&gt;cleaner and easier interface to the hardware&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://barondu.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSC" scheme="http://barondu.com/tags/OSC/"/>
    
      <category term="Introduction" scheme="http://barondu.com/tags/Introduction/"/>
    
  </entry>
  
</feed>
